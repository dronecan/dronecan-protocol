// dronecan_system_packets.c was generated by ProtoGen version 2.19.a

/**

Copyright (c) 2020 DroneCAN

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

**/

#include "dronecan_system_packets.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Create the DroneCAN_DeviceStatus packet
 *
 * Device status information
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeDroneCAN_DeviceStatusPacketStructure(void* _pg_pkt)
{
    int _pg_byteindex = 0;

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_DeviceStatusPacketID());
}

/*!
 * \brief Decode the DroneCAN_DeviceStatus packet
 *
 * Device status information
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID is wrong, else 1
 */
int decodeDroneCAN_DeviceStatusPacketStructure(const void* _pg_pkt)
{
    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_DeviceStatusPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the DroneCAN_DeviceStatus packet
 *
 * Device status information
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeDroneCAN_DeviceStatusPacket(void* _pg_pkt)
{
    // Zero length packet, no data encoded
    finishDroneCANPacket(_pg_pkt, 0, getDroneCAN_DeviceStatusPacketID());
}

/*!
 * \brief Decode the DroneCAN_DeviceStatus packet
 *
 * Device status information
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_DeviceStatusPacket(const void* _pg_pkt)
{
    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_DeviceStatusPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the DroneCAN_UniqueId packet
 *
 * Unique identifier for DroneCAN device
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeDroneCAN_UniqueIdPacketStructure(void* _pg_pkt, const DroneCAN_UniqueId_t* _pg_user)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Vendor ID
    uint16ToBeBytes(_pg_user->vid, _pg_data, &_pg_byteindex);

    // Product ID
    uint16ToBeBytes(_pg_user->pid, _pg_data, &_pg_byteindex);

    // Device serial number
    uint24ToBeBytes((uint32_t)(_pg_user->serial), _pg_data, &_pg_byteindex);

    // CAN node address
    uint8ToBytes(_pg_user->address, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_UniqueIdPacketID());
}

/*!
 * \brief Decode the DroneCAN_UniqueId packet
 *
 * Unique identifier for DroneCAN device
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_UniqueIdPacketStructure(const void* _pg_pkt, DroneCAN_UniqueId_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_UniqueIdPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getDroneCANPacketSize(_pg_pkt);
    if(_pg_numbytes < getDroneCAN_UniqueIdMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getDroneCANPacketDataConst(_pg_pkt);

    // Vendor ID
    _pg_user->vid = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Product ID
    _pg_user->pid = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Device serial number
    _pg_user->serial = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    // CAN node address
    _pg_user->address = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_UniqueId packet
 *
 * Unique identifier for DroneCAN device
 * \param _pg_pkt points to the packet which will be created by this function
 * \param vid is Vendor ID
 * \param pid is Product ID
 * \param serial is Device serial number
 * \param address is CAN node address
 */
void encodeDroneCAN_UniqueIdPacket(void* _pg_pkt, uint16_t vid, uint16_t pid, uint32_t serial, uint8_t address)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Vendor ID
    uint16ToBeBytes(vid, _pg_data, &_pg_byteindex);

    // Product ID
    uint16ToBeBytes(pid, _pg_data, &_pg_byteindex);

    // Device serial number
    uint24ToBeBytes((uint32_t)(serial), _pg_data, &_pg_byteindex);

    // CAN node address
    uint8ToBytes(address, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_UniqueIdPacketID());
}

/*!
 * \brief Decode the DroneCAN_UniqueId packet
 *
 * Unique identifier for DroneCAN device
 * \param _pg_pkt points to the packet being decoded by this function
 * \param vid receives Vendor ID
 * \param pid receives Product ID
 * \param serial receives Device serial number
 * \param address receives CAN node address
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_UniqueIdPacket(const void* _pg_pkt, uint16_t* vid, uint16_t* pid, uint32_t* serial, uint8_t* address)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_UniqueIdPacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_UniqueIdMinDataLength())
        return 0;

    // Vendor ID
    *vid = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Product ID
    *pid = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Device serial number
    *serial = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    // CAN node address
    *address = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_ManufacturerString packet
 *
 * Manufacturer identifier string
 * \param _pg_pkt points to the packet which will be created by this function
 * \param manufacturerString is Manufactuer string
 */
void encodeDroneCAN_ManufacturerStringPacket(void* _pg_pkt, const char manufacturerString[64])
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Manufactuer string
    stringToBytes(manufacturerString, _pg_data, &_pg_byteindex, 64, 0);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_ManufacturerStringPacketID());
}

/*!
 * \brief Decode the DroneCAN_ManufacturerString packet
 *
 * Manufacturer identifier string
 * \param _pg_pkt points to the packet being decoded by this function
 * \param manufacturerString receives Manufactuer string
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_ManufacturerStringPacket(const void* _pg_pkt, char manufacturerString[64])
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_ManufacturerStringPacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_ManufacturerStringMinDataLength())
        return 0;

    // Manufactuer string
    stringFromBytes(manufacturerString, _pg_data, &_pg_byteindex, 64, 0);

    return 1;
}

/*!
 * \brief Create the DroneCAN_UserString packet
 *
 * Manufacturer identifier string
 * \param _pg_pkt points to the packet which will be created by this function
 * \param userString is User configurable string
 */
void encodeDroneCAN_UserStringPacket(void* _pg_pkt, const char userString[64])
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // User configurable string
    stringToBytes(userString, _pg_data, &_pg_byteindex, 64, 0);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_UserStringPacketID());
}

/*!
 * \brief Decode the DroneCAN_UserString packet
 *
 * Manufacturer identifier string
 * \param _pg_pkt points to the packet being decoded by this function
 * \param userString receives User configurable string
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_UserStringPacket(const void* _pg_pkt, char userString[64])
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_UserStringPacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_UserStringMinDataLength())
        return 0;

    // User configurable string
    stringFromBytes(userString, _pg_data, &_pg_byteindex, 64, 0);

    return 1;
}

/*!
 * \brief Create the DroneCAN_FirmwareVersion packet
 *
 * Firmware version information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeDroneCAN_FirmwareVersionPacketStructure(void* _pg_pkt, const DroneCAN_FirmwareVersion_t* _pg_user)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes(_pg_user->versionMajor, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->versionMinor, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->versionSub, _pg_data, &_pg_byteindex);

    uint32ToBeBytes(_pg_user->checksum, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_FirmwareVersionPacketID());
}

/*!
 * \brief Decode the DroneCAN_FirmwareVersion packet
 *
 * Firmware version information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_FirmwareVersionPacketStructure(const void* _pg_pkt, DroneCAN_FirmwareVersion_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_FirmwareVersionPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getDroneCANPacketSize(_pg_pkt);
    if(_pg_numbytes < getDroneCAN_FirmwareVersionMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getDroneCANPacketDataConst(_pg_pkt);

    _pg_user->versionMajor = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->versionMinor = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->versionSub = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->checksum = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_FirmwareVersion packet
 *
 * Firmware version information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param versionMajor is 
 * \param versionMinor is 
 * \param versionSub is 
 * \param checksum is 
 */
void encodeDroneCAN_FirmwareVersionPacket(void* _pg_pkt, uint8_t versionMajor, uint8_t versionMinor, uint8_t versionSub, uint32_t checksum)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes(versionMajor, _pg_data, &_pg_byteindex);

    uint8ToBytes(versionMinor, _pg_data, &_pg_byteindex);

    uint8ToBytes(versionSub, _pg_data, &_pg_byteindex);

    uint32ToBeBytes(checksum, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_FirmwareVersionPacketID());
}

/*!
 * \brief Decode the DroneCAN_FirmwareVersion packet
 *
 * Firmware version information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param versionMajor receives 
 * \param versionMinor receives 
 * \param versionSub receives 
 * \param checksum receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_FirmwareVersionPacket(const void* _pg_pkt, uint8_t* versionMajor, uint8_t* versionMinor, uint8_t* versionSub, uint32_t* checksum)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_FirmwareVersionPacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_FirmwareVersionMinDataLength())
        return 0;

    *versionMajor = uint8FromBytes(_pg_data, &_pg_byteindex);

    *versionMinor = uint8FromBytes(_pg_data, &_pg_byteindex);

    *versionSub = uint8FromBytes(_pg_data, &_pg_byteindex);

    *checksum = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_FirmwareDate packet
 *
 * Firmware date information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeDroneCAN_FirmwareDatePacketStructure(void* _pg_pkt, const DroneCAN_FirmwareDate_t* _pg_user)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes(_pg_user->versionYear, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->versionMonth, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->versionDay, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_FirmwareDatePacketID());
}

/*!
 * \brief Decode the DroneCAN_FirmwareDate packet
 *
 * Firmware date information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_FirmwareDatePacketStructure(const void* _pg_pkt, DroneCAN_FirmwareDate_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_FirmwareDatePacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getDroneCANPacketSize(_pg_pkt);
    if(_pg_numbytes < getDroneCAN_FirmwareDateMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getDroneCANPacketDataConst(_pg_pkt);

    _pg_user->versionYear = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    _pg_user->versionMonth = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->versionDay = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_FirmwareDate packet
 *
 * Firmware date information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param versionYear is 
 * \param versionMonth is 
 * \param versionDay is 
 */
void encodeDroneCAN_FirmwareDatePacket(void* _pg_pkt, uint16_t versionYear, uint8_t versionMonth, uint8_t versionDay)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes(versionYear, _pg_data, &_pg_byteindex);

    uint8ToBytes(versionMonth, _pg_data, &_pg_byteindex);

    uint8ToBytes(versionDay, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_FirmwareDatePacketID());
}

/*!
 * \brief Decode the DroneCAN_FirmwareDate packet
 *
 * Firmware date information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param versionYear receives 
 * \param versionMonth receives 
 * \param versionDay receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_FirmwareDatePacket(const void* _pg_pkt, uint16_t* versionYear, uint8_t* versionMonth, uint8_t* versionDay)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_FirmwareDatePacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_FirmwareDateMinDataLength())
        return 0;

    *versionYear = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    *versionMonth = uint8FromBytes(_pg_data, &_pg_byteindex);

    *versionDay = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_FirmwareSettings packet
 *
 * User-configurable settings information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeDroneCAN_FirmwareSettingsPacketStructure(void* _pg_pkt, const DroneCAN_FirmwareSettings_t* _pg_user)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Checksum of all user-configurable device settings
    uint32ToBeBytes(_pg_user->settingsChecksum, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_FirmwareSettingsPacketID());
}

/*!
 * \brief Decode the DroneCAN_FirmwareSettings packet
 *
 * User-configurable settings information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_FirmwareSettingsPacketStructure(const void* _pg_pkt, DroneCAN_FirmwareSettings_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_FirmwareSettingsPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getDroneCANPacketSize(_pg_pkt);
    if(_pg_numbytes < getDroneCAN_FirmwareSettingsMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getDroneCANPacketDataConst(_pg_pkt);

    // Checksum of all user-configurable device settings
    _pg_user->settingsChecksum = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_FirmwareSettings packet
 *
 * User-configurable settings information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param settingsChecksum is Checksum of all user-configurable device settings
 */
void encodeDroneCAN_FirmwareSettingsPacket(void* _pg_pkt, uint32_t settingsChecksum)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Checksum of all user-configurable device settings
    uint32ToBeBytes(settingsChecksum, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_FirmwareSettingsPacketID());
}

/*!
 * \brief Decode the DroneCAN_FirmwareSettings packet
 *
 * User-configurable settings information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param settingsChecksum receives Checksum of all user-configurable device settings
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_FirmwareSettingsPacket(const void* _pg_pkt, uint32_t* settingsChecksum)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_FirmwareSettingsPacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_FirmwareSettingsMinDataLength())
        return 0;

    // Checksum of all user-configurable device settings
    *settingsChecksum = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_HardwareInfo packet
 *
 * Hardware information
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeDroneCAN_HardwareInfoPacketStructure(void* _pg_pkt)
{
    int _pg_byteindex = 0;

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_HardwareInfoPacketID());
}

/*!
 * \brief Decode the DroneCAN_HardwareInfo packet
 *
 * Hardware information
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID is wrong, else 1
 */
int decodeDroneCAN_HardwareInfoPacketStructure(const void* _pg_pkt)
{
    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_HardwareInfoPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the DroneCAN_HardwareInfo packet
 *
 * Hardware information
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeDroneCAN_HardwareInfoPacket(void* _pg_pkt)
{
    // Zero length packet, no data encoded
    finishDroneCANPacket(_pg_pkt, 0, getDroneCAN_HardwareInfoPacketID());
}

/*!
 * \brief Decode the DroneCAN_HardwareInfo packet
 *
 * Hardware information
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_HardwareInfoPacket(const void* _pg_pkt)
{
    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_HardwareInfoPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the DroneCAN_ProtocolInfo packet
 *
 * DroneCAN protocol information
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeDroneCAN_ProtocolInfoPacket(void* _pg_pkt)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes((uint16_t)(getDroneCANApi()), _pg_data, &_pg_byteindex);

    stringToBytes(getDroneCANVersion(), _pg_data, &_pg_byteindex, 6, 0);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_ProtocolInfoPacketID());
}

/*!
 * \brief Decode the DroneCAN_ProtocolInfo packet
 *
 * DroneCAN protocol information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param dcApi receives 
 * \param dcVersion receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_ProtocolInfoPacket(const void* _pg_pkt, uint16_t* dcApi, char dcVersion[6])
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_ProtocolInfoPacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_ProtocolInfoMinDataLength())
        return 0;

    *dcApi = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    stringFromBytes(dcVersion, _pg_data, &_pg_byteindex, 6, 0);

    return 1;
}
// end of dronecan_system_packets.c
