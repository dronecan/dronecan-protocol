// dronecan_parameter_packets.c was generated by ProtoGen version 2.19.a

/**

Copyright (c) 2020 DroneCAN

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

**/

#include "dronecan_parameter_packets.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Create the DroneCAN_ParameterRequest packet
 *
 * Request device parameter
 * \param _pg_pkt points to the packet which will be created by this function
 * \param format is 
 */
void encodeDroneCAN_ParameterRequestPacket(void* _pg_pkt, uint8_t format)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes(format, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_ParameterRequestPacketID());
}

/*!
 * \brief Decode the DroneCAN_ParameterRequest packet
 *
 * Request device parameter
 * \param _pg_pkt points to the packet being decoded by this function
 * \param format receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_ParameterRequestPacket(const void* _pg_pkt, uint8_t* format)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_ParameterRequestPacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_ParameterRequestMinDataLength())
        return 0;

    *format = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_ParameterInfo packet
 *
 * Parameter description
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeDroneCAN_ParameterInfoPacketStructure(void* _pg_pkt, const DroneCAN_ParameterInfo_t* _pg_user)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes(_pg_user->index, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->format, _pg_data, &_pg_byteindex);

    stringToBytes(_pg_user->name, _pg_data, &_pg_byteindex, 96, 0);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_ParameterInfoPacketID());
}

/*!
 * \brief Decode the DroneCAN_ParameterInfo packet
 *
 * Parameter description
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_ParameterInfoPacketStructure(const void* _pg_pkt, DroneCAN_ParameterInfo_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_ParameterInfoPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getDroneCANPacketSize(_pg_pkt);
    if(_pg_numbytes < getDroneCAN_ParameterInfoMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getDroneCANPacketDataConst(_pg_pkt);

    _pg_user->index = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    _pg_user->format = uint8FromBytes(_pg_data, &_pg_byteindex);

    stringFromBytes(_pg_user->name, _pg_data, &_pg_byteindex, 96, 0);

    return 1;
}

/*!
 * \brief Create the DroneCAN_ParameterNull packet
 *
 * Encode a 'null' or 'void' parameter
 * \param _pg_pkt points to the packet which will be created by this function
 * \param index is 
 */
void encodeDroneCAN_ParameterNullPacket(void* _pg_pkt, uint16_t index)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes(index, _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(DRONECAN_PARAMETER_VOID), _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_ParameterNullPacketID());
}

/*!
 * \brief Decode the DroneCAN_ParameterNull packet
 *
 * Encode a 'null' or 'void' parameter
 * \param _pg_pkt points to the packet being decoded by this function
 * \param index receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_ParameterNullPacket(const void* _pg_pkt, uint16_t* index)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_ParameterNullPacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_ParameterNullMinDataLength())
        return 0;

    *index = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Decoded value must be DRONECAN_PARAMETER_VOID
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) DRONECAN_PARAMETER_VOID)
        return 0;

    return 1;
}

/*!
 * \brief Create the DroneCAN_ParameterValueBytes packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet which will be created by this function
 * \param index is 
 * \param data is 
 */
void encodeDroneCAN_ParameterValueBytesPacket(void* _pg_pkt, uint16_t index, const uint8_t data[4])
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;
    unsigned _pg_i = 0;

    uint16ToBeBytes(index, _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(DRONECAN_PARAMETER_BYTES), _pg_data, &_pg_byteindex);

    for(_pg_i = 0; _pg_i < 4; _pg_i++)
        uint8ToBytes(data[_pg_i], _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_ParameterValueBytesPacketID());
}

/*!
 * \brief Decode the DroneCAN_ParameterValueBytes packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet being decoded by this function
 * \param index receives 
 * \param data receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_ParameterValueBytesPacket(const void* _pg_pkt, uint16_t* index, uint8_t data[4])
{
    unsigned _pg_i = 0;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_ParameterValueBytesPacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_ParameterValueBytesMinDataLength())
        return 0;

    *index = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Decoded value must be DRONECAN_PARAMETER_BYTES
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) DRONECAN_PARAMETER_BYTES)
        return 0;

    for(_pg_i = 0; _pg_i < 4; _pg_i++)
        data[_pg_i] = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_ParameterValueS8 packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet which will be created by this function
 * \param index is 
 * \param data is 
 */
void encodeDroneCAN_ParameterValueS8Packet(void* _pg_pkt, uint16_t index, int8_t data)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes(index, _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(DRONECAN_PARAMETER_SINT8), _pg_data, &_pg_byteindex);

    int8ToBytes(data, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_ParameterValueS8PacketID());
}

/*!
 * \brief Decode the DroneCAN_ParameterValueS8 packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet being decoded by this function
 * \param index receives 
 * \param data receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_ParameterValueS8Packet(const void* _pg_pkt, uint16_t* index, int8_t* data)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_ParameterValueS8PacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_ParameterValueS8MinDataLength())
        return 0;

    *index = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Decoded value must be DRONECAN_PARAMETER_SINT8
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) DRONECAN_PARAMETER_SINT8)
        return 0;

    *data = int8FromBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_ParameterValueU8 packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet which will be created by this function
 * \param index is 
 * \param data is 
 */
void encodeDroneCAN_ParameterValueU8Packet(void* _pg_pkt, uint16_t index, uint8_t data)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes(index, _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(DRONECAN_PARAMETER_UINT8), _pg_data, &_pg_byteindex);

    uint8ToBytes(data, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_ParameterValueU8PacketID());
}

/*!
 * \brief Decode the DroneCAN_ParameterValueU8 packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet being decoded by this function
 * \param index receives 
 * \param data receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_ParameterValueU8Packet(const void* _pg_pkt, uint16_t* index, uint8_t* data)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_ParameterValueU8PacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_ParameterValueU8MinDataLength())
        return 0;

    *index = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Decoded value must be DRONECAN_PARAMETER_UINT8
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) DRONECAN_PARAMETER_UINT8)
        return 0;

    *data = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_ParameterValueS16 packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet which will be created by this function
 * \param index is 
 * \param data is 
 */
void encodeDroneCAN_ParameterValueS16Packet(void* _pg_pkt, uint16_t index, int16_t data)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes(index, _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(DRONECAN_PARAMETER_SINT16), _pg_data, &_pg_byteindex);

    int16ToBeBytes(data, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_ParameterValueS16PacketID());
}

/*!
 * \brief Decode the DroneCAN_ParameterValueS16 packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet being decoded by this function
 * \param index receives 
 * \param data receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_ParameterValueS16Packet(const void* _pg_pkt, uint16_t* index, int16_t* data)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_ParameterValueS16PacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_ParameterValueS16MinDataLength())
        return 0;

    *index = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Decoded value must be DRONECAN_PARAMETER_SINT16
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) DRONECAN_PARAMETER_SINT16)
        return 0;

    *data = int16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_ParameterValueU16 packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet which will be created by this function
 * \param index is 
 * \param data is 
 */
void encodeDroneCAN_ParameterValueU16Packet(void* _pg_pkt, uint16_t index, uint16_t data)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes(index, _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(DRONECAN_PARAMETER_UINT16), _pg_data, &_pg_byteindex);

    uint16ToBeBytes(data, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_ParameterValueU16PacketID());
}

/*!
 * \brief Decode the DroneCAN_ParameterValueU16 packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet being decoded by this function
 * \param index receives 
 * \param data receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_ParameterValueU16Packet(const void* _pg_pkt, uint16_t* index, uint16_t* data)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_ParameterValueU16PacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_ParameterValueU16MinDataLength())
        return 0;

    *index = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Decoded value must be DRONECAN_PARAMETER_UINT16
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) DRONECAN_PARAMETER_UINT16)
        return 0;

    *data = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_ParameterValueS32 packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet which will be created by this function
 * \param index is 
 * \param data is 
 */
void encodeDroneCAN_ParameterValueS32Packet(void* _pg_pkt, uint16_t index, int32_t data)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes(index, _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(DRONECAN_PARAMETER_SINT32), _pg_data, &_pg_byteindex);

    int32ToBeBytes(data, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_ParameterValueS32PacketID());
}

/*!
 * \brief Decode the DroneCAN_ParameterValueS32 packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet being decoded by this function
 * \param index receives 
 * \param data receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_ParameterValueS32Packet(const void* _pg_pkt, uint16_t* index, int32_t* data)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_ParameterValueS32PacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_ParameterValueS32MinDataLength())
        return 0;

    *index = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Decoded value must be DRONECAN_PARAMETER_SINT32
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) DRONECAN_PARAMETER_SINT32)
        return 0;

    *data = int32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_ParameterValueU32 packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet which will be created by this function
 * \param index is 
 * \param data is 
 */
void encodeDroneCAN_ParameterValueU32Packet(void* _pg_pkt, uint16_t index, uint32_t data)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes(index, _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(DRONECAN_PARAMETER_UINT32), _pg_data, &_pg_byteindex);

    uint32ToBeBytes(data, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_ParameterValueU32PacketID());
}

/*!
 * \brief Decode the DroneCAN_ParameterValueU32 packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet being decoded by this function
 * \param index receives 
 * \param data receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_ParameterValueU32Packet(const void* _pg_pkt, uint16_t* index, uint32_t* data)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_ParameterValueU32PacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_ParameterValueU32MinDataLength())
        return 0;

    *index = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Decoded value must be DRONECAN_PARAMETER_UINT32
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) DRONECAN_PARAMETER_UINT32)
        return 0;

    *data = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_ParameterValueFloat packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet which will be created by this function
 * \param index is 
 * \param data is 
 */
void encodeDroneCAN_ParameterValueFloatPacket(void* _pg_pkt, uint16_t index, float data)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes(index, _pg_data, &_pg_byteindex);

    uint8ToBytes((uint8_t)(DRONECAN_PARAMETER_FLOAT), _pg_data, &_pg_byteindex);

    float32ToBeBytes((float)data, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_ParameterValueFloatPacketID());
}

/*!
 * \brief Decode the DroneCAN_ParameterValueFloat packet
 *
 * Parameter value
 * \param _pg_pkt points to the packet being decoded by this function
 * \param index receives 
 * \param data receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_ParameterValueFloatPacket(const void* _pg_pkt, uint16_t* index, float* data)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_ParameterValueFloatPacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_ParameterValueFloatMinDataLength())
        return 0;

    *index = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Decoded value must be DRONECAN_PARAMETER_FLOAT
    if (uint8FromBytes(_pg_data, &_pg_byteindex) != (uint8_t) DRONECAN_PARAMETER_FLOAT)
        return 0;

    *data = float32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;
}
// end of dronecan_parameter_packets.c
